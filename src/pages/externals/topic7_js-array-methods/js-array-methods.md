---
title: Методы массивов в JavaScript
templateKey: 'article-page'
order: 1
---

# Методы массивов в JavaScript

## Массивы

Вспомним определение массива.  
**Массив (Array)** – разновидность объекта, которая предназначена для хранения _пронумерованных_ значений и имеет дополнительные методы для удобного манипулирования такой коллекцией.

Создания массива:
```js
const animals = ['cat', 'dog'];

const emptyArray = [];

const arrayWithGaps = [1,, 2, 3]; // допускается не указывать элементы массива
```

Всем элементам массива соответствует индекс, нумерация начинается с `0`.  
У каждого массива есть свойство **length**, которое возвращает число элементов массива (определённых и не определённых). Его значение допусткается переопределять.   
Доступ к элементу массива осуществляется по индексу.

```js
const animals = ['cat', 'dog'];

console.log(animals[0]); // 'cat'
console.log(animals[1]); // 'dog'
console.log(animals[2]); // undefined
console.log(animals.length); // 2 
```

Допустимо обращаться к индексам, по которым не хранятся какие либо значения, результатом обращения будет `undefined`.

Значения, соответствующие определённым индексам, можно переприсваивать.
```js
const animals = ['cat', 'dog'];

console.log(animals[0]); // 'cat'
animals[0] = 'cow';
console.log(animals[0]); // 'cow'
```
При изменении какого либо элемента, ссылка на массив, хранящаяся в переменной `animals`, останется неизменной, однако сам массив (а точнее один из его элементов) изменится. Это также называют **мутацией**.  

Встроенный объект __Array__ находится в глобальной области видимости и также может использоваться для создания массивов. У него есть несколько удобных методов для работы с массивами. Например `Array.isArray(выражение)` -  возвращает `true`, если значение выражения является массивом, иначе возвращает `false`.

Все массивы наследуются от `Array.prototype`, который содержит большое количество удобных методов.

## Стек, очередь

Массивы являются довольно гибкой структурой данных. Они позволяют реализовать работу с данными по правилам __стека__ или __очереди__.

**Стек** - тип данных, представляющий собой список элементов, организованных по принципу **LIFO** (англ. last in — first out, «последним пришёл — первым вышел»).

Для работы с последним элементом массива используются методы **push** и **pop** (push - добавляет элемент в конец массива, pop - удаляет последний).
```js
const animals = ['cat', 'dog'];

animals.push('rabbit');
console.log(animals); // ['cat', 'dog', 'rabbit'];

animals.push('horse');
console.log(animals); // ['cat', 'dog', 'rabbit', 'horse'];

animals.pop();
console.log(animals); // ['cat', 'dog', 'rabbit'];
```
В данном случае наш массив играет роль _стека_, удаляется только последний пришедший элемент.

Для работы с началом массива есть методы **shift** и **unshift** (shift - удаление, unshift - добавление).
```js
const animals = ['cat', 'dog'];

animals.shift();
console.log(animals); // ['dog'];

animals.unshift('horse');
console.log(animals); // ['horse', 'dog'];
```

**Очередь** - тип данных, представляющий собой список элементов, организованных по принципу **FIFO** (англ. first in, first out, «первый пришёл — первый вышел»). Чтобы реализовать __очередь__ нам понадобятся методы **shift** и **push**.

## Методы массивов

Итак, мы разобрали простые методы для работы с элементами начала и конца массива. Обратите внимание, все 4 метода изменяют массив __на месте__, т.е. массив остается тем же, изменяется лишь содержание - происходит __мутация__. Это не всегда хорошо (например нам может понадобиться исходная версия массива еще раз). При использовании метода необходимо учитывать, будет ли он изменять сам массив.

В этом разделе мы остановимся лишь на самых часто используемых методах, ссылку на более детальное описание методов можно найти в конце раздела.

## Копирование массива
### Slice (Array.prototype.slice)

`array.slice([begin[, end]])`

Данный метод возвращает новый массив, содержащий копию(полную или частичную) исходного массива. 

```js
const animals = ['cat', 'dog', 'rabbit', 'horse', 'parrot'];

const copy = animals.slice();

console.log(copy) // ['cat', 'dog', 'rabbit', 'horse', 'parrot']
console.log(animals.slice(1)) // ['dog', 'rabbit', 'horse', 'parrot']
console.log(animals.slice(1, 2)) // ['dog']
console.log(animals.slice(2, -1)) // ['rabbit', 'horse']
```
Есть созвучный метод **splice**, он изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые (тем самым мутируя массив).

## Перебор массива
### ForEach (Array.prototype.forEach)

`array.forEach(function (currentValue, index, array) { ...код функции... } [, thisArg]);`

Метод **forEach** является базовым методом для перебора массива и выполняет указанную функцию один раз для каждого элемента.
В качестве аргументов в колбек будут передаваться:
-  _currentValue_ - текущий обрабатываемый элемент массива;
-  _index_ - индекс обрабатываемого элемента массива;
-  _array_ - ссылка на сам массив;

```js
['cat', 'dog', 'rabbit'].forEach((currentValue, index) => {
    console.log(currentValue, index);
});
// cat 0
// dog 1
// rabbit 2
```

## Вычисления на основе существующего массива
### Filter (Array.prototype.filter)

`const result = array.filter(function (currentValue, index, array) { ...код функции... } [, thisArg]);`

Метод **filter** создаёт __новый__ массив со всеми элементами, прошедшими проверку, заданную в передаваемой функции. Исходный массив остаётся неизменным.  

```js
const shortValuesArray = ['cat', 'dog', 'rabbit'].filter(currentValue => currentValue.length <= 3); // ['cat', 'dog']
```
Здесь осуществляется преобразование результата вызова функции для каждого элемента в `boolean` (если оно таковым не является).

### Map (Array.prototype.map)

`const result = array.map(function (currentValue, index, array) { ...код функции... } [, thisArg]);`

Метод **map** создаёт __новый__ массив с результатом вызова указанной функции для каждого элемента массива.

```js
const firstLetters = ['cat', 'dog', 'rabbit'].map(currentValue => currentValue.length); // [3, 3, 6]
```

### Reduce (Array.prototype.reduce)

`const result = array.reduce(function (accumulator, currentValue, index, array) { ...код функции... } [, initialValue]);`

Метод **reduce** применяет функцию к каждому элементу массива (слева-направо), по окончанию выполнения возвращая одно результирующее значение. Также есть метод **reduceRight**, который отличается лишь "направлением" перебора (справа-налево).

В качестве первого аргумента будет передаваться так называемый _аккумулятор_.  
Есть несколько особенностей работы данного метода. Во время инициализации происходит установление значения аккумулятора. Если указано начальное значение **initialValue**, то аккумулятор примет его значение и перебор начинается с первого элемента массива. В противном случае аккумулятор принимает значение первого элемента массива и перебор начинается со **!второго!** элемента.

```js
const totalLength = ['cat', 'dog', 'rabbit'].reduce((length, currentValue) => length + currentValue.length, 0); // 12
```

## Поиск в массиве
### indexOf (Array.prototype.indexOf)

`const result = array.indexOf(searchElement[, fromIndex = 0])`

Возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.

```js
const animals = ['cat', 'dog', 'parrot'];

console.log(animals.indexOf('dog')); // 1
```
Похожий метод **lastIndexOf** возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет. Массив просматривается от конца к началу, начиная с индекса fromIndex.

### Find (Array.prototype.find)

`const result = array.find(function (currentValue, index, array) { ...код функции... } [, thisArg]);`

Метод **find** возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию, переданному в callback функции.  В противном случае возвращается `undefined`.

## Сортировка
### Sort (Array.prototype.sort)

`array.sort([compareFunction])`

Метод **sort** __!на месте!__ сортирует элементы массива и возвращает отсортированный массив (т.е. мутирует массив). Порядок cортировки по умолчанию соответствует порядку кодовых точек Unicode. Это значит, что если не передавать **compareFunction**, то сортировка будет происходить так, как если бы это были строки.  
**compareFunction** принимает два аргумента - два значения, которые необходимо сравнить определенным образом. Возможные возвращаемые значения:
-  `0` элементы равны
-  `<0` первый элемент будет помещен раньше второго
-  `>0` второй элемент будет помещен раньше первого

```js
const numbers = ['1', '12', '2'];

numbers.sort((a, b) => a - b);

console.log(numbers); // ['1', '2', '12']
```

**Важно!** Функция должна всегда возвращать одинаковое значение для определённой пары элементов. Если будут возвращаться непоследовательные результаты, порядок сортировки будет не определён.

Более подробную информацию по методам массивов смотри на сайте [developer.mozilla.org](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array#Array_generic_methods).
